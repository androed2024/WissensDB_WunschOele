"""
Streamlit application for the RAG AI agent.
Virt Umgebung aktivieren: source .venv/bin/activate
Aufruf App: streamlit run app.py
"""

# Add parent directory to path to allow relative imports
import sys
import os

# Projektbasisverzeichnis zum Pfad hinzuf√ºgen (eine Ebene √ºber 'ui')
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

# Logging
import logging

# Date+Time for post knowledge in db
from datetime import datetime
import pytz
import uuid

from base64 import b64encode

from supabase import create_client


# Reduce verbosity by logging only informational messages and above
logging.basicConfig(level=logging.INFO)

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from agent.agent import format_source_reference

import asyncio
import time
from typing import List, Dict, Any
from pathlib import Path
import tempfile
from datetime import datetime
import streamlit as st
import streamlit.components.v1 as st_components
import unicodedata
import re
import hashlib
import pandas as pd


def compute_file_hash(file_bytes: bytes) -> str:
    return hashlib.sha256(file_bytes).hexdigest()


from collections import defaultdict

# Logo-Pfad im Root-Verzeichnis
logo_path = "logo-wunschoele.png"

# Logo-Datei als base64 laden
with open(logo_path, "rb") as image_file:
    encoded = b64encode(image_file.read()).decode()

try:
    from st_aggrid import AgGrid, GridOptionsBuilder

    AGGRID = True
except Exception:
    AGGRID = False

def sanitize_filename(filename: str) -> str:
    filename = filename.strip()
    filename = filename.replace("√§", "ae").replace("√∂", "oe").replace("√º", "ue")
    filename = filename.replace("√Ñ", "Ae").replace("√ñ", "Oe").replace("√ú", "Ue")
    filename = filename.replace("√ü", "ss")
    filename = (
        unicodedata.normalize("NFKD", filename)
        .encode("ascii", "ignore")
        .decode("ascii")
    )
    filename = re.sub(r"[^a-zA-Z0-9_.-]", "_", filename)
    return filename


from dotenv import load_dotenv

load_dotenv()

import mimetypes

# Import progress tracking modules
from progress_tracker import ProgressTracker
from helpers_progress import count_text_chars, estimate_total_chunks

# Environment variables with defaults
EMBED_BATCH_SIZE = int(os.getenv("EMBED_BATCH_SIZE", "5"))
DB_BATCH_SIZE = int(os.getenv("DB_BATCH_SIZE", "100"))

SUPABASE_URL = os.environ["SUPABASE_URL"]
SUPABASE_SERVICE_ROLE_KEY = os.environ["SUPABASE_SERVICE_ROLE_KEY"]
SUPABASE_ANON_KEY = os.environ["SUPABASE_ANON_KEY"]

# Auth-Client (f√ºr Login/Passwort √§ndern)
sb_auth = create_client(SUPABASE_URL, SUPABASE_ANON_KEY)

# Admin-Client (Service Role f√ºr Benutzerverwaltung - nur serverseitig verwenden!)
SB_ADMIN = create_client(SUPABASE_URL, os.environ["SUPABASE_SERVICE_ROLE_KEY"])


app_version = os.getenv("APP_VERSION", "0.0")
print("DEBUG VERSION:", os.getenv("APP_VERSION"))

from document_processing.ingestion import DocumentIngestionPipeline
from database.setup import SupabaseClient
from agent.agent import (
    RAGAgent,
    agent as rag_agent,
    format_source_reference,
    get_supabase_client,
    AgenticRetrievalOrchestrator,
    AgenticRetrievalConfig,
)
from pydantic_ai.messages import (
    ModelRequest,
    ModelResponse,
    PartDeltaEvent,
    PartStartEvent,
    TextPartDelta,
)

st.set_page_config(
    page_title="Wunsch √ñle Wissens-Agent",
    page_icon="üîç",
    layout="wide",
    initial_sidebar_state="collapsed",  # Hide sidebar since agentic retrieval is always-on
)

# CSS f√ºr kompakteres Layout + Conditional Sidebar
st.markdown(
    """
<style>
/* 1) Alles Top-Padding/Margin global entfernen */
html, body { margin:0 !important; padding:0 !important; }
#root, [data-testid="stAppViewContainer"] { margin:0 !important; padding-top:0 !important; }

/* 2) Sidebar f√ºr Threaded Chat verf√ºgbar machen - wird per JavaScript kontrolliert */
section[data-testid="stSidebar"] {
    width: 280px !important;
    min-width: 280px !important;
}
.css-1d391kg {
    display: block !important;
}
div[data-testid="collapsedControl"] {
    display: block !important;
}

/* 2) Streamlit-Header, Toolbar, Deko und Status komplett entfernen (ohne reservierte H√∂he) */
header[data-testid="stHeader"],
div[data-testid="stDecoration"],
div[data-testid="stToolbar"],
div[data-testid="stStatusWidget"] {
  display:none !important;
  height:0 !important;
  min-height:0 !important;
  visibility:hidden !important;
}

/* 3) Main-Container oben b√ºndig machen */
section[data-testid="stMain"] { padding-top:0 !important; margin-top:0 !important; }

/* 4) Der eigentliche Block-Container: wirklich KEIN top spacing */
section[data-testid="stMain"] > div.block-container {
  padding-top:0 !important;
  margin-top:0 !important;
  padding-left:2rem !important;
  padding-right:2rem !important;
  max-width:none !important;
}

/* 5) Streamlit "Spacers" killen (verursachen oft den letzten Rest Abstand) */
div[data-testid="stSpacer"] {
  display:none !important;
  height:0 !important;
  min-height:0 !important;
  padding:0 !important;
  margin:0 !important;
}

/* 6) Ersten sichtbaren Block explizit b√ºndig setzen */
section[data-testid="stMain"] > div.block-container > div:first-child {
  margin-top:0 !important;
  padding-top:0 !important;
}

/* 7) Tabs/Controls kompakter (optional) */
.stTabs [data-baseweb="tab-list"] { margin-top:0 !important; }
</style>
""",
    unsafe_allow_html=True,
)


# --- CSS: hyperlink-style popover + small counters ---
st.markdown("""
<style>
/* Pfeil im Popover-Trigger auf die Zeile zwingen */
[data-testid="stPopover"] svg {
  display: inline !important;
  vertical-align: baseline !important;
  margin-left: 4px;
}
<style>
/* small counters */
.counts {
  font-size: 13px;
  color: #444;
  margin: 0;
  line-height: 1.1;
  display: inline-block;
}

/* make the st.popover trigger look like a plain link (no border, no background) */
[data-testid="stPopover"] button,
[data-testid="stPopover"] div[role="button"] {
  all: unset !important;          /* nuke default button styles */
  display: inline !important;
  color: #0d6efd !important;      /* link blue */
  font-size: 13px !important;
  line-height: 1.1 !important;
  cursor: pointer !important;
  text-decoration: underline !important;
}
[data-testid="stPopover"] button:hover,
[data-testid="stPopover"] div[role="button"]:hover {
  text-decoration: none !important;
}
</style>
""", unsafe_allow_html=True)





def render_user_popover_contents():
    """Rendert den Inhalt des User-Popovers (Rollen, Passwort √§ndern, Logout)."""
    u = st.session_state.get("user")
    if not u: return
    roles = ", ".join(st.session_state.get("roles", [])) or "keine Rollen"
    
    st.caption(f"Rollen: {roles}")
    old = st.text_input("Altes Passwort", type="password", key="pw_old")
    new = st.text_input("Neues Passwort", type="password", key="pw_new")
    if st.button("Passwort √§ndern"):
        try:
            # Re-Auth (falls n√∂tig) & Passwort setzen
            sb_auth.auth.sign_in_with_password({"email": u.email, "password": old})
            sb_auth.auth.update_user({"password": new})
            st.success("Passwort ge√§ndert.")
        except Exception as e:
            st.error(f"√Ñnderung fehlgeschlagen: {e}")
    if st.button("Logout"):
        sb_auth.auth.sign_out()
        for k in ("session","user","roles","sb_user"):
            st.session_state.pop(k, None)
        st.rerun()

# --- Header-Zeile (Z√§hler links, User rechts) ---
def render_header():
    doc_count  = st.session_state.get("document_count", 0)
    note_count = st.session_state.get("knowledge_count", 0)

    # 1) Erste Zeile: Titel (links) + User-Link (rechts)
    col_title, col_user = st.columns([5, 2], gap="small")

    with col_title:
        st.markdown(
            f"""
            <div style="display:flex;align-items:center;gap:8px;margin:0;padding:0;">
              <img src="data:image/png;base64,{encoded}" alt="Logo" style="height:32px;">
              <span style="font-size:18px;font-weight:600;">Wunsch-√ñle Wissens Agent</span>
              <span style="color:#007BFF;font-size:12px;">üîß Version: {app_version}</span>
            </div>
            """,
            unsafe_allow_html=True,
        )

    with col_user:
        user = st.session_state.get("user")
        if user:
            label = user.email if getattr(user, "email", None) else "User"
            # rechtsb√ºndig, kein zus√§tzlicher Button-Look
            st.markdown(
                '<div style="display:flex;justify-content:flex-end;align-items:center;margin:0;">',
                unsafe_allow_html=True
            )
            with st.popover(f"User: {label}"):   # kein use_container_width
                render_user_popover_contents()
            st.markdown('</div>', unsafe_allow_html=True)

    # 2) Zweite Zeile: Z√§hler links, (rechts bleibt leer)
    col_counts, _ = st.columns([5, 2], gap="small")
    with col_counts:
        st.markdown(
            f'<div class="counts">üìÑ Dokumente: {doc_count}&nbsp;&nbsp; üß† Notizen: {note_count}</div>',
            unsafe_allow_html=True,
        )

    # d√ºnne Trennlinie unter dem gesamten Header
    st.markdown('<hr style="margin:2px 0 6px 0;border-top-width:1px;">', unsafe_allow_html=True)

        

supabase_client = SupabaseClient()

# Agent instances will be created with appropriate client (Service for admin, User for others)
def get_agentic_orchestrator():
    """Get AgenticRetrievalOrchestrator with appropriate client for user role."""
    sb = get_db_client_for_admin_operations()
    return AgenticRetrievalOrchestrator(db_client=sb)

def get_rag_agent():
    """Get RAGAgent with appropriate client for user role."""
    sb = get_db_client_for_admin_operations()
    return RAGAgent(db_client=sb)

async def run_agentic_retrieval_with_guards(user_input: str, config: AgenticRetrievalConfig) -> Dict[str, Any]:
    """
    Run agentic retrieval with intelligent guards applied.
    
    Args:
        user_input: User's question
        config: Agentic retrieval configuration
        
    Returns:
        Dict with answer and source chunks
    """
    print(f"\nüîµ [USER INPUT] Original-Frage (Agentisch): {user_input}")
    
    try:
        orchestrator = get_agentic_orchestrator()
        
        # First attempt with original config
        result = await orchestrator.run(user_input, config)
        confidence = result.get('confidence', 0.0)
        source_chunks = result.get('source_chunks', [])
        
        print(f"üéØ Erste Runde abgeschlossen. Confidence: {confidence}, Treffer: {len(source_chunks)}")
        
        # Guard 2: Confidence-Gate - if confidence < 0.5 after round 2, start round 3
        if confidence < 0.5 and config.max_rounds >= 2:
            print("üîÑ Confidence-Gate: Confidence < 0.5 - starte erweiterte Runde 3")
            
            # Enhance the query with expanded search terms  
            enhanced_config = AgenticRetrievalConfig(
                max_rounds=3,  # Force round 3
                k_per_round=config.k_per_round + 3,  # More candidates
                token_budget=config.token_budget,
                min_similarity=max(config.min_similarity - 0.05, 0.45),  # Slightly lower threshold
                recency_halflife_days=config.recency_halflife_days,
                doc_type_preference=config.doc_type_preference,
                enable_filters=config.enable_filters,
                early_stopping_threshold=0.65,  # Lower bar for acceptance
                quality_over_speed=True  # Ensure thorough search
            )
            
            # Run enhanced retrieval
            result = await orchestrator.run(user_input, enhanced_config)
            source_chunks = result.get('source_chunks', [])
            print(f"üöÄ Erweiterte Runde abgeschlossen. Neue Treffer: {len(source_chunks)}")
        
        # Guard 3: Recall-Boost for low results (applied retroactively if needed)  
        if len(source_chunks) < 3:
            print("üîç Recall-Boost: Zu wenige Treffer - erweitere Suche")
            recall_config = apply_recall_boost_if_needed(len(source_chunks), config)
            if recall_config.min_similarity != config.min_similarity or recall_config.k_per_round != config.k_per_round:
                # Re-run with boosted settings
                result = await orchestrator.run(user_input, recall_config)
                source_chunks = result.get('source_chunks', [])
                print(f"‚ú® Recall-Boost abgeschlossen. Finale Treffer: {len(source_chunks)}")
        
        # Set last_match for UI compatibility (store in session_state for persistence)
        st.session_state['last_agentic_matches'] = source_chunks
            
        return result
        
    except Exception as e:
        print(f"‚ùå Agentisches Retrieval Fehler: {e}")
        import traceback
        traceback.print_exc()
        return {
            "answer": "Es ist ein Fehler beim agentischen Retrieval aufgetreten.",
            "source_chunks": [],
            "error": str(e)
        }

# Backwards compatibility wrapper
async def run_agentic_retrieval(user_input: str, config: AgenticRetrievalConfig) -> Dict[str, Any]:
    """Backwards compatibility wrapper - now always uses guards."""
    return await run_agentic_retrieval_with_guards(user_input, config)

def _build_user_client(access_token: str):
    """Erzeuge einen Supabase-Client, der mit dem User-JWT gegen PostgREST authentifiziert ist (RLS greift)."""
    sb = create_client(SUPABASE_URL, SUPABASE_ANON_KEY)
    sb.postgrest.auth(access_token)
    return sb

def ensure_login():
    if "user" in st.session_state and "sb_user" in st.session_state:
        return

    st.subheader("Anmelden")

    # Atomare Form: vermeidet Rerun-Rennen & Autofill-Probleme
    with st.form("login_form", clear_on_submit=False):
        st.text_input("E-Mail", key="login_email", value=st.session_state.get("login_email",""))
        st.text_input("Passwort", type="password", key="login_pw")
        submit = st.form_submit_button("Anmelden", use_container_width=True)

    if not submit:
        st.stop()

    # Werte NACH Submit aus session_state ziehen (stabil bei Autofill)
    email = (st.session_state.get("login_email") or "").strip()
    pw    = st.session_state.get("login_pw") or ""

    if not email or not pw:
        st.error("Bitte E-Mail und Passwort eingeben.")
        st.stop()

    try:
        # SDK-Kompatibilit√§t (dict vs. named args)
        try:
            res = sb_auth.auth.sign_in_with_password({"email": email, "password": pw})
        except TypeError:
            res = sb_auth.auth.sign_in_with_password(email=email, password=pw)

        st.session_state["session"] = res.session
        st.session_state["user"]    = res.user
        st.session_state["roles"]   = (res.user.app_metadata or {}).get("roles", [])
        st.session_state["sb_user"] = _build_user_client(res.session.access_token)
        st.rerun()

    except Exception as e:
        st.error(f"Login fehlgeschlagen: {e}")
        st.stop()


def get_sb_user():
    """Hole den User-Client (mit JWT)."""
    return st.session_state.get("sb_user")

def get_db_client_for_admin_operations():
    """
    Hole den passenden DB-Client f√ºr Admin-Operationen.
    Admins bekommen Service-Client f√ºr uneingeschr√§nkten Zugriff,
    normale User bekommen User-Client mit RLS.
    """
    if get_user_role() == "admin":
        return SB_ADMIN  # Service-Client f√ºr Admins
    else:
        return get_sb_user()  # User-Client f√ºr normale User

def get_db_client_for_chat_operations():
    """
    Hole den passenden DB-Client f√ºr Chat-Historie-Operationen.
    Alle berechtigten User (chatbot_user, data_user, admin) bekommen Service-Client,
    da RLS-Policies f√ºr chat_history oft zu restriktiv sind.
    """
    if has_permission("chat"):
        return SB_ADMIN  # Service-Client f√ºr alle Chat-berechtigten User
    else:
        return get_sb_user()  # User-Client als Fallback

def get_db_client_for_upload_operations():
    """
    Hole den passenden DB-Client f√ºr Upload-/Document-Processing-Operationen.
    data_user und admin bekommen Service-Client f√ºr uneingeschr√§nkten Upload-Zugriff,
    da RLS-Policies f√ºr document_metadata und rag_pages oft zu restriktiv sind.
    """
    if has_permission("upload"):
        return SB_ADMIN  # Service-Client f√ºr Upload-berechtigte User
    else:
        return get_sb_user()  # User-Client als Fallback

def get_user_role():
    """Gibt die eine Rolle des Users zur√ºck"""
    roles = st.session_state.get("roles", [])
    return roles[0] if roles else None

def has_permission(feature: str):
    """Pr√ºft Berechtigung basierend auf Rollenhierarchie"""
    role = get_user_role()
    if role == "admin":
        return True  # Admin kann alles
    elif role == "data_user":
        return feature in ["chat", "upload", "delete", "notes", "chat_history"]
    elif role == "chatbot_user": 
        return feature in ["chat", "chat_history"]
    return False

def user_menu():
    """Popover rechts oben: Rollen anzeigen, Passwort √§ndern, Logout."""
    u = st.session_state.get("user")
    if not u: return
    roles = ", ".join(st.session_state.get("roles", [])) or "keine Rollen"

    with st.popover(f"User: {u.email}"):
        st.caption(f"Rollen: {roles}")
        old = st.text_input("Altes Passwort", type="password", key="pw_old")
        new = st.text_input("Neues Passwort", type="password", key="pw_new")
        if st.button("Passwort √§ndern"):
            try:
                # Re-Auth (falls n√∂tig) & Passwort setzen
                sb_auth.auth.sign_in_with_password({"email": u.email, "password": old})
                sb_auth.auth.update_user({"password": new})
                st.success("Passwort ge√§ndert.")
            except Exception as e:
                st.error(f"√Ñnderung fehlgeschlagen: {e}")
        if st.button("Logout"):
            sb_auth.auth.sign_out()
            for k in ("session","user","roles","sb_user"):
                st.session_state.pop(k, None)
            st.rerun()


# ==== Admin-Funktionen f√ºr Benutzerverwaltung ====

def list_users():
    """Liste aller Benutzer mit Rollen abrufen."""
    try:
        result = SB_ADMIN.auth.admin.list_users()
        users = []
        for user in result:
            roles = user.app_metadata.get("roles", []) if user.app_metadata else []
            users.append({
                "id": user.id,
                "email": user.email,
                "roles": roles
            })
        return users
    except Exception as e:
        st.error(f"Fehler beim Laden der Benutzer: {e}")
        return []

def set_roles(uid: str, roles: list):
    """Rollen f√ºr einen Benutzer setzen."""
    try:
        SB_ADMIN.auth.admin.update_user_by_id(uid, {"app_metadata": {"roles": roles}})
        return True
    except Exception as e:
        st.error(f"Fehler beim Setzen der Rollen: {e}")
        return False

def create_user(email: str, roles: list, password: str):
    """Neuen Benutzer erstellen."""
    try:
        user_data = {
            "email": email,
            "password": password,
            "email_confirm": True,
            "app_metadata": {"roles": roles}
        }
        
        result = SB_ADMIN.auth.admin.create_user(user_data)
        st.success("Benutzer angelegt, kann sich sofort anmelden.")
        return True
    except Exception as e:
        st.error(f"Fehler beim Erstellen des Benutzers: {e}")
        return False

def delete_user(uid: str):
    """Benutzer l√∂schen."""
    try:
        SB_ADMIN.auth.admin.delete_user(uid)
        return True
    except Exception as e:
        st.error(f"Fehler beim L√∂schen des Benutzers: {e}")
        return False


# ==== Ende Admin-Funktionen ====


# Hardcoded agentic retrieval configuration - always enabled
AGENTIC_DEFAULTS = {
    "enabled": True,
    "max_rounds": 2,
    "candidates_per_round": 12,
    "tool_token_budget": 2000,
    "min_similarity": 0.55,
    "quality_over_speed": True,
    "recency_half_life_days": 90,
    "doc_type_preference": None,
    "advanced_filters": {"language": "de"},
    "early_stopping_threshold": 0.75,
    "retrieval": {
        "initial_topk": 60,
        "rerank_topk": 50,
        "keep_topk": 8,
        "max_chunks_per_source": 3,
        "context_chunks": 5,
        "context_token_cap": 1200
    }
}

def apply_agentic_guards(query: str, base_config: AgenticRetrievalConfig) -> AgenticRetrievalConfig:
    """Apply intelligent guards to adapt agentic configuration based on query characteristics."""
    
    # Guard 1: Temporal-Cue-Switch
    temporal_keywords = re.compile(r'\b(heute|aktuell|neu|neuen|neueste|letztes? Jahr|vergangene|j√ºngste|rezent|current|latest|recent)\b', re.IGNORECASE)
    if temporal_keywords.search(query):
        print("üïí Temporal-Cue-Switch: Reduziere Recency Half-life auf 30 Tage f√ºr zeitbezogene Anfrage")
        base_config.recency_halflife_days = 30
    
    return base_config

def apply_recall_boost_if_needed(results_count: int, base_config: AgenticRetrievalConfig) -> AgenticRetrievalConfig:
    """Guard 3: Recall-Boost bei Nulltreffern - apply after initial search to boost recall."""
    if results_count < 3:
        print("üöÄ Recall-Boost: Weniger als 3 Treffer - senke Min-Similarity und erh√∂he Kandidaten")
        base_config.min_similarity = 0.50
        base_config.k_per_round = 15
    
    return base_config

def get_always_on_agentic_config(query: str = "") -> AgenticRetrievalConfig:
    """Get the always-on agentic retrieval configuration with intelligent guards."""
    
    # Create base configuration
    config = AgenticRetrievalConfig(
        max_rounds=AGENTIC_DEFAULTS["max_rounds"],
        k_per_round=AGENTIC_DEFAULTS["candidates_per_round"],
        token_budget=AGENTIC_DEFAULTS["tool_token_budget"],
        min_similarity=AGENTIC_DEFAULTS["min_similarity"],
        recency_halflife_days=AGENTIC_DEFAULTS["recency_half_life_days"],
        doc_type_preference=AGENTIC_DEFAULTS["doc_type_preference"],
        enable_filters=True,
        early_stopping_threshold=AGENTIC_DEFAULTS["early_stopping_threshold"],
        quality_over_speed=AGENTIC_DEFAULTS["quality_over_speed"]
    )
    
    # Apply intelligent guards
    if query:
        config = apply_agentic_guards(query, config)
    
    print(f"ü§ñ Agentisches Retrieval (Always-On) - Konfiguration: max_rounds={config.max_rounds}, k_per_round={config.k_per_round}, min_similarity={config.min_similarity}, recency_halflife={config.recency_halflife_days}")
    
    return config


if "messages" not in st.session_state:
    st.session_state.messages = []

if "sources" not in st.session_state:
    st.session_state.sources = []

if "processed_files" not in st.session_state:
    st.session_state.processed_files = set()

# Initialize chat history session state
if "chat_history_search" not in st.session_state:
    st.session_state.chat_history_search = ""

if "selected_chat_id" not in st.session_state:
    st.session_state.selected_chat_id = None

# ---- Session State for Threaded Chat ----
if "current_thread_id" not in st.session_state:
    st.session_state.current_thread_id = None
if "thread_title_set" not in st.session_state:
    st.session_state.thread_title_set = False
if "current_user_name" not in st.session_state:
    # Setze hier deinen eingeloggten User; falls du bereits eine Variable hast, synchronisieren
    st.session_state.current_user_name = getattr(st.session_state, "user_email", "test2@gmail.com")


def new_thread():
    """Erzeugt eine neue Thread-ID und setzt thread_title_set zur√ºck"""
    st.session_state.current_thread_id = str(uuid.uuid4())
    st.session_state.thread_title_set = False


def save_chat_row(user_name: str, question: str, answer: str, sources: List = None):
    """Speichert ein Q/A-Paar in der chat_history Tabelle mit thread_id"""
    thread_id = st.session_state.current_thread_id
    assert thread_id, "Kein aktiver Thread. Bitte new_thread() aufrufen."

    # ersten Prompt als Titel speichern
    thread_title = question if not st.session_state.thread_title_set else None

    payload = {
        "created_at": datetime.utcnow().isoformat() + "Z",
        "user_name": user_name,
        "thread_id": thread_id,
        "question": question,
        "answer": answer,
    }
    if thread_title:
        payload["thread_title"] = thread_title

    try:
        # Use appropriate client for chat operations
        sb = get_db_client_for_chat_operations()
        sb.table("chat_history").insert(payload).execute()

        if thread_title:
            st.session_state.thread_title_set = True
    except Exception as e:
        print(f"‚ùå Fehler beim Speichern der Chat-Row: {e}")


def load_thread(thread_id: str) -> List[Dict[str, Any]]:
    """L√§dt alle Q/A-Paare f√ºr einen spezifischen Thread"""
    try:
        sb = get_db_client_for_chat_operations()
        res = sb.table("chat_history")\
            .select("question, answer, created_at")\
            .eq("thread_id", thread_id)\
            .order("created_at", desc=False)\
            .execute()
        return res.data or []
    except Exception as e:
        print(f"‚ùå Fehler beim Laden des Threads {thread_id}: {e}")
        return []


def build_agent_context(rows: List[Dict[str, Any]]):
    """Baut den Agent-Kontext aus Thread-Historie auf"""
    messages = []
    for r in rows:
        if r.get("question"):
            messages.append({"role": "user", "content": r["question"]})
        if r.get("answer"):
            messages.append({"role": "assistant", "content": r["answer"]})
    return messages


def list_threads_for_user(user_name: str):
    """Listet die letzten Threads f√ºr einen User auf"""
    try:
        sb = get_db_client_for_chat_operations()
        # Wir holen die letzten 200 Zeilen und konsolidieren in Python
        res = sb.table("chat_history")\
            .select("thread_id, thread_title, created_at")\
            .eq("user_name", user_name)\
            .order("created_at", desc=True)\
            .limit(200).execute()
        rows = res.data or []
        by_thread = {}
        for r in rows:
            tid = r["thread_id"]
            if tid not in by_thread:
                by_thread[tid] = {"thread_id": tid,
                                  "thread_title": r.get("thread_title") or "Ohne Titel",
                                  "last_activity": r["created_at"]}
        threads = list(by_thread.values())
        threads.sort(key=lambda x: x["last_activity"], reverse=True)
        return threads[:30]
    except Exception as e:
        print(f"‚ùå Fehler beim Laden der Thread-Liste f√ºr {user_name}: {e}")
        return []


def display_message_part(part):
    if part.part_kind == "user-prompt" and part.content:
        with st.chat_message("user"):
            st.markdown(part.content)
    elif part.part_kind == "text" and part.content:
        with st.chat_message("assistant"):
            st.markdown(part.content)


from typing import Callable, Optional

# Type alias for phase callback
PhaseCB = Callable[[str, int, int], None]


async def process_document(
    file_path: str,
    safe_filename: str,
    metadata: Dict[str, Any],
    on_phase: Optional[PhaseCB] = None,
) -> Dict[str, Any]:
    """
    Asynchrone Dokumentenverarbeitung mit Phasen-Callbacks.

    Args:
        file_path: Pfad zur zu verarbeitenden Datei
        safe_filename: Sicherer Dateiname f√ºr die Speicherung
        metadata: Metadaten f√ºr das Dokument
        on_phase: Optional callback f√ºr Phasen-Updates (phase, processed, total)

    Returns:
        Dict mit success, chunk_count und ggf. error
    """
    # Use appropriate client (Service for data_user and admin, User for others)
    sb = get_db_client_for_upload_operations()
    pipeline = DocumentIngestionPipeline(db_client=sb)
    loop = asyncio.get_event_loop()

    try:
        # P4: Finalisierung wird am Ende aufgerufen  
        def wrapped_on_phase(phase: str, processed: int, total: int):
            if on_phase:
                try:
                    # Execute callback in thread-safe manner
                    on_phase(phase, processed, total)
                except Exception as e:
                    # Suppress ScriptRunContext errors - they're expected from background threads
                    if "ScriptRunContext" not in str(e):
                        print(f"‚ö†Ô∏è Fehler bei Progress-Update ({phase}): {e}")
                    # Always continue processing even if UI update fails

        chunks = await loop.run_in_executor(
            None,
            lambda: pipeline.process_file(
                file_path, metadata, on_phase=wrapped_on_phase
            ),
        )

        if not chunks:
            return {
                "success": False,
                "file_path": file_path,
                "error": "Keine g√ºltigen Textabschnitte gefunden",
            }

        # P4: Finalisierung - Sign URLs, Checks, Cache Warmup
        if on_phase:
            on_phase("finalize", 0, 1)

        print("\nüì¶ Embedding-Check")
        try:
            # 'chunks' enth√§lt APIResponse-Objekte; wir flatten auf Row-Dicts
            rows = []
            for resp in chunks:
                # Supabase-Python: resp.data ist i.d.R. eine Liste mit genau 1 Row (der Insert)
                if hasattr(resp, "data") and isinstance(resp.data, list):
                    rows.extend(resp.data)
                elif isinstance(resp, dict):
                    rows.append(resp)
                else:
                    # Unbekanntes Format -> skip
                    continue

            for i, row in enumerate(rows):
                emb = row.get("embedding") if isinstance(row, dict) else None
                txt = row.get("content", "") if isinstance(row, dict) else ""
                emb_len = len(emb) if isinstance(emb, (list, tuple)) else (emb.shape[0] if hasattr(emb, "shape") else 0)
                print(f"Chunk {i+1}: Embedding: {emb_len} Werte | Text: {txt[:100].replace(chr(10), ' ')}...")
        except Exception as e:
            print(f"‚ö†Ô∏è Embedding-Check √ºbersprungen: {e}")

        
        
        # Finalisierung abgeschlossen
        if on_phase:
            on_phase("finalize", 1, 1)

        return {"success": True, "file_path": file_path, "chunk_count": len(chunks)}
    except Exception as e:
        import traceback

        print(f"Fehler bei der Bearbeitung des Dokuments: {str(e)}")
        print(traceback.format_exc())
        return {"success": False, "file_path": file_path, "error": str(e)}


async def run_agent_with_streaming(user_input: str, rag_agent_instance):
    # Log der Original-Frage vom User
    print(f"\nüîµ [USER INPUT] Original-Frage: {user_input}")

    async with rag_agent_instance.agent.iter(
        user_input,
        deps={"kb_search": rag_agent_instance.kb_search},
        message_history=st.session_state.messages,
    ) as run:
        async for node in run:
            if hasattr(node, "request") and isinstance(node.request, ModelRequest):
                async with node.stream(run.ctx) as request_stream:
                    async for event in request_stream:
                        if (
                            isinstance(event, PartStartEvent)
                            and event.part.part_kind == "text"
                        ):
                            yield event.part.content
                        elif isinstance(event, PartDeltaEvent) and isinstance(
                            event.delta, TextPartDelta
                        ):
                            yield event.delta.content_delta

    st.session_state.messages.extend(run.result.new_messages())


def get_chat_history(search_term: str = "") -> List[Dict]:
    """Holt Chat-Historie aus Supabase mit optionaler Wildcard-Suche"""
    try:
        # Service-Client f√ºr alle Chat-berechtigten User (chatbot_user, data_user, admin)
        sb = get_db_client_for_chat_operations()
        query = sb.table("chat_history").select("*")

        if search_term.strip():
            # Wildcard-Suche auf Frage-Feld
            search_pattern = f"%{search_term}%"
            query = query.ilike("question", search_pattern)

        response = query.order("created_at", desc=True).execute()
        return response.data or []
    except Exception as e:
        print(f"Fehler beim Abrufen der Chat-Historie: {e}")
        return []


def get_chat_messages_for_display() -> List[Dict]:
    """
    Holt die letzten 10 Chat-Nachrichten f√ºr die Anzeige im aktuellen Chat-Tab.
    Dies ist der aktuelle, persistente Chat-Verlauf - nicht die gesamte Historie.
    """
    try:
        sb = get_db_client_for_chat_operations()

        print("üîç [DEBUG] Lade aktuelle Chat-Nachrichten f√ºr Anzeige")

        # Lade die letzten 10 Nachrichten des aktuellen Users (chronologisch)
        if st.session_state.get("user"):
            user_email = st.session_state["user"].email
            response = sb.table("chat_history").select("*").eq("user_name", user_email).order("created_at", desc=True).limit(10).execute()
            messages = response.data or []

            # Sortiere chronologisch (√§lteste zuerst) f√ºr die Anzeige
            messages.sort(key=lambda x: x.get("created_at", ""), reverse=False)

            print(f"‚úÖ [DEBUG] {len(messages)} aktuelle Chat-Nachrichten geladen")
            return messages
        else:
            print("‚ö†Ô∏è [DEBUG] Kein User - leerer Chat")
            return []

    except Exception as e:
        print(f"‚ùå [DEBUG] Fehler beim Laden der aktuellen Chat-Nachrichten: {e}")
        return []

def get_chat_messages_by_id(message_id: str) -> List[Dict]:
    """Holt eine spezifische Chat-Nachricht anhand ihrer ID (f√ºr Chat-Historie)"""
    try:
        sb = get_db_client_for_chat_operations()

        # Lade die spezifische Nachricht anhand ihrer ID
        if message_id:
            response = sb.table("chat_history").select("*").eq("id", message_id).execute()
            messages = response.data or []
            print(f"‚úÖ [DEBUG] {len(messages)} Nachricht(en) f√ºr Message-ID {message_id} geladen")
            return messages
        else:
            return []

    except Exception as e:
        print(f"‚ùå [DEBUG] Fehler beim Laden der Chat-Nachricht f√ºr ID {message_id}: {e}")
        return []


def save_chat_message(chat_id: str, role: str, content: str, sources: List = None):
    """Speichert eine Chat-Nachricht in der Datenbank"""
    try:
        sb = get_db_client_for_chat_operations()
        
        print(f"üîç [DEBUG] Speichere {role}-Nachricht f√ºr chat_id: {chat_id}")
        
        # Sichere JSON-Serialisierung der Sources
        clean_sources = []
        if sources:
            try:
                import json
                for source in sources:
                    if isinstance(source, dict):
                        # Konvertiere numpy/pandas Datentypen zu Python-nativen Typen
                        clean_source = {}
                        for key, value in source.items():
                            if hasattr(value, 'item'):  # numpy int64, float64, etc.
                                clean_source[key] = value.item()
                            elif isinstance(value, (list, dict)):
                                clean_source[key] = json.loads(json.dumps(value, default=str))
                            else:
                                clean_source[key] = value
                        clean_sources.append(clean_source)
                    else:
                        clean_sources.append(str(source))  # Fallback: als String speichern
                        
                # Test JSON-Serialisierung
                json.dumps(clean_sources)
                print(f"‚úÖ [DEBUG] Sources JSON-serialisiert: {len(clean_sources)} Eintr√§ge")
            except Exception as json_error:
                print(f"‚ö†Ô∏è [DEBUG] Sources JSON-Fehler: {json_error} - verwende leere Liste")
                clean_sources = []
        
        # Erstelle Record im alten Schema-Format
        if role == "user":
            chat_record = {
                "user_name": st.session_state.get("user", {}).email or "user",
                "question": content,
                "answer": "",
                "sources": clean_sources
            }
        else:  # assistant
            chat_record = {
                "user_name": st.session_state.get("user", {}).email or "user", 
                "question": "",
                "answer": content,
                "sources": clean_sources
            }
        
        # Robuste Serialisierung aller Datentypen
        def make_json_safe(obj):
            """Konvertiere alle nicht-JSON-serialisierbaren Objekte"""
            if hasattr(obj, 'item'):  # numpy types
                return obj.item()
            elif isinstance(obj, dict):
                return {key: make_json_safe(value) for key, value in obj.items()}
            elif isinstance(obj, list):
                return [make_json_safe(item) for item in obj]
            elif isinstance(obj, (int, float, str, bool, type(None))):
                return obj
            else:
                return str(obj)  # Fallback: als String speichern

        # Spezielle Behandlung f√ºr sources - diese k√∂nnen komplexe Objekte enthalten
        if sources:
            try:
                import json
                # Test-Serialisierung der sources
                json.dumps(sources, default=str)
                print(f"‚úÖ [DEBUG] Sources sind bereits JSON-kompatibel: {len(sources)} Eintr√§ge")
            except (TypeError, ValueError) as e:
                print(f"‚ö†Ô∏è [DEBUG] Sources m√ºssen bereinigt werden: {e}")
                # Bereinige sources mit make_json_safe
                clean_sources = make_json_safe(sources)
        else:
            clean_sources = []

        chat_record = make_json_safe(chat_record)
        
        # Versuche mit chat_id 
        try:
            chat_record["chat_id"] = str(chat_id)  # Chat-ID als String
            result = sb.table("chat_history").insert(chat_record).execute()
            print(f"‚úÖ [DEBUG] {role}-Nachricht mit chat_id gespeichert")
            return
        except Exception as e:
            if "chat_id" in str(e) or "column" in str(e).lower():
                print("‚ö†Ô∏è [DEBUG] chat_id Spalte nicht verf√ºgbar")
                chat_record.pop("chat_id", None)
            else:
                print(f"‚ö†Ô∏è [DEBUG] DB-Fehler mit chat_id: {e}")
                
        # Fallback: ohne chat_id  
        try:
            if st.session_state.get("user"):
                chat_record["user_id"] = str(st.session_state["user"].id)  # User-ID als String
            result = sb.table("chat_history").insert(chat_record).execute()
            print(f"‚úÖ [DEBUG] {role}-Nachricht ohne chat_id gespeichert")
        except Exception as e2:
            if "user_id" in str(e2) or "column" in str(e2).lower():
                chat_record.pop("user_id", None)
                result = sb.table("chat_history").insert(chat_record).execute()
                print(f"‚úÖ [DEBUG] {role}-Nachricht Legacy-Schema gespeichert")
            else:
                raise e2
        
    except Exception as e:
        print(f"‚ùå [DEBUG] Fataler Fehler beim Speichern {role}-Nachricht: {e}")
        import traceback
        traceback.print_exc()


def _chat_history_df(chat_history: List[Dict]) -> pd.DataFrame:
    """Hilfsfunktion f√ºr das DataFRame (chat_history tabelle)"""
    rows = []
    for ch in chat_history:
        q = (ch.get("question") or "").strip().replace("\n", " ")
        # sehr kompakt k√ºrzen
        if len(q) > 120:
            q = q[:117] + "..."
        # Nur Datumsteil anzeigen (YYYY-MM-DD)
        ts = (ch.get("created_at") or "")[:10]
        rows.append(
            {
                "id": ch.get("id"),
                "Datum": ts,
                "Frage": q,
            }
        )
    df = pd.DataFrame(rows)
    # stabile Sortierung: neu ‚Üí alt
    if "Datum" in df.columns:
        df = df.sort_values("Datum", ascending=False)
    # Index zur√ºcksetzen und nicht als Spalte anzeigen
    df = df.reset_index(drop=True)
    return df

def render_chat_history():
    """Suche oben, klickbare Tabelle links (AgGrid) und Details rechts."""

    # ‚îÄ‚îÄ Suche ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    search_term = st.text_input(
        "üîé Suche in Fragen (Wildcard-Suche)",
        value="",
        placeholder="Geben Sie Suchbegriff ein...",
        key="chat_history_search_input",
        help="Die Suche erfolgt automatisch w√§hrend der Eingabe"
    )

    # ‚îÄ‚îÄ Daten ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Live-Suche: Verwende den aktuellen search_term direkt
    chat_history = get_chat_history(search_term.strip())
    if not chat_history:
        st.info(
            f"Keine Chats gefunden f√ºr: '{search_term.strip()}'"
            if search_term.strip()
            else "Keine Chat-Historie verf√ºgbar."
        )
        return

    chat_df = _chat_history_df(chat_history)  # id, Datum, Frage
    grid_df = chat_df[["Datum", "Frage", "id"]].reset_index(drop=True)

    # Auswahl-Management: Reset bei Suche oder Initialisierung
    current_selected_id = st.session_state.get("selected_chat_id")
    available_ids = set(grid_df["id"].tolist()) if len(grid_df) > 0 else set()
    
    # Reset selection wenn aktuelle ID nicht in gefilterten Ergebnissen ist
    if current_selected_id not in available_ids and len(grid_df) > 0:
        st.session_state.selected_chat_id = grid_df.loc[0, "id"]
        print(f"[CHAT] reset selected_chat_id -> {st.session_state.selected_chat_id} (search filter changed)")
    elif not current_selected_id and len(grid_df) > 0:
        st.session_state.selected_chat_id = grid_df.loc[0, "id"]
        print(f"[CHAT] init selected_chat_id -> {st.session_state.selected_chat_id}")

    # ‚îÄ‚îÄ Layout ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    col_list, col_detail = st.columns([1, 2])

    # ‚îÄ‚îÄ Hilfsfunktion: Auswahl sicher aus AgGridReturn holen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _get_selected_rows(grid_return) -> list[dict]:
        try:
            # Dict-Return (√§ltere Versionen)
            if isinstance(grid_return, dict):
                rows = grid_return.get("selected_rows") or grid_return.get("selectedRows") or []
            else:
                # Neuere Version: Attribute k√∂nnen DataFrames sein
                rows = getattr(grid_return, "selected_rows", None)
                if rows is None:
                    rows = getattr(grid_return, "selectedRows", None)

            # Normalisieren
            if rows is None:
                return []
            import pandas as _pd
            if isinstance(rows, _pd.DataFrame):
                return rows.to_dict("records")
            if isinstance(rows, list):
                return rows
            # Fallback: unbekannter Typ ‚Üí in Liste packen, wenn Mapping
            try:
                return [dict(rows)]
            except Exception:
                return []
        except Exception as e:
            print(f"[CHAT] _get_selected_rows error: {e}")
            return []

    # ‚îÄ‚îÄ Linke Spalte: Tabelle / AgGrid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    with col_list:
        st.markdown("**Chat-Liste:**")

        if AGGRID:
            from st_aggrid import GridOptionsBuilder
            gb = GridOptionsBuilder.from_dataframe(grid_df)
            gb.configure_column("id", hide=True)
            gb.configure_column("Datum", headerName="Datum", width=110, resizable=True)
            gb.configure_column("Frage", headerName="Frage", flex=1, wrapText=True, autoHeight=True)
            gb.configure_default_column(resizable=True, sortable=True, filter=True)
            gb.configure_selection(selection_mode="single", use_checkbox=False)
            gb.configure_grid_options(
                rowHeight=28,
                suppressRowClickSelection=False,
                animateRows=False,
                domLayout="autoHeight",
                rememberSelection=True,
            )

            grid_key = f"chat_history_grid_v5_{len(grid_df)}_{search_term.strip()}"

            # Neu: update_on (neue API)  ‚Üí Fallback: update_mode (alte API)
            try:
                grid = AgGrid(
                    grid_df,
                    gridOptions=gb.build(),
                    update_on=["selectionChanged"],     # <- wichtig
                    fit_columns_on_grid_load=True,
                    allow_unsafe_jscode=True,
                    enable_enterprise_modules=False,
                    theme="alpine",
                    key=grid_key,
                )
            except TypeError:
                from st_aggrid import GridUpdateMode
                grid = AgGrid(
                    grid_df,
                    gridOptions=gb.build(),
                    update_mode=GridUpdateMode.SELECTION_CHANGED,
                    fit_columns_on_grid_load=True,
                    allow_unsafe_jscode=True,
                    enable_enterprise_modules=False,
                    theme="alpine",
                    key=grid_key,
                )

            print(f"[CHAT] grid type: {type(grid)}")
            selected_rows = _get_selected_rows(grid)
            print(f"[CHAT] selected_rows len = {len(selected_rows)}")

            if selected_rows:
                row0 = selected_rows[0]
                print(f"[CHAT] first selected row keys: {list(row0.keys())}")
                sel_id = row0.get("id")

                # Falls 'id' durch Hide nicht mitkommt ‚Üí anhand Datum/Frage rekonstruieren
                if not sel_id:
                    try:
                        match = grid_df[
                            (grid_df["Datum"] == row0.get("Datum")) &
                            (grid_df["Frage"] == row0.get("Frage"))
                        ]
                        if len(match) == 1:
                            sel_id = match.iloc[0]["id"]
                            print(f"[CHAT] reconstructed id -> {sel_id}")
                    except Exception as e:
                        print(f"[CHAT] reconstruct failed: {e}")

                if sel_id and sel_id != st.session_state.get("selected_chat_id"):
                    st.session_state.selected_chat_id = sel_id
                    print(f"[CHAT] >> selection changed -> {sel_id} (rerun)")
                    st.rerun()
                else:
                    print("[CHAT] selection unchanged or id missing")

            # Kompakteres Grid CSS
            st.markdown(
                """
                <style>
                .ag-theme-alpine .ag-cell { padding: 2px 4px !important; font-size: 12px !important; line-height: 1.2 !important; }
                .ag-theme-alpine .ag-header-cell-label { padding: 2px 4px !important; font-size: 12px !important; font-weight: 600 !important; }
                .ag-theme-alpine .ag-row { min-height: 28px !important; }
                </style>
                """,
                unsafe_allow_html=True,
            )
        else:
            # Fallback ohne AgGrid
            options = grid_df["id"].tolist()
            labels = [f"{row['Datum']} ‚Äî {row['Frage']}" for _, row in grid_df.iterrows()]
            current = st.session_state.get("selected_chat_id")
            idx = options.index(current) if current in options else 0 if options else None
            if options:
                selection = st.radio(" ", options=options, index=idx,
                                     format_func=lambda x: labels[options.index(x)])
                if selection and selection != current:
                    st.session_state.selected_chat_id = selection
                    print(f"[CHAT] radio -> selection changed to {selection} (rerun)")
                    st.rerun()
            else:
                st.info("Keine Eintr√§ge.")

    # ‚îÄ‚îÄ Rechte Spalte: Chat-Details ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    with col_detail:
        st.markdown("**Chat-Details:**")
        sel_id = st.session_state.get("selected_chat_id")
        print(f"[CHAT] details sel_id = {sel_id}")

        if sel_id:
            # Finde die spezifische Chat-Nachricht in den geladenen Daten
            selected_chat = next((c for c in chat_history if c.get("id") == int(sel_id)), None)
            print(f"[CHAT] found selected_chat? -> {bool(selected_chat)}")
            
            if selected_chat:
                # Zeige die ausgew√§hlte Nachricht
                if selected_chat.get("question") and selected_chat.get("question").strip():
                    with st.chat_message("user"):
                        st.markdown(selected_chat["question"])
                
                if selected_chat.get("answer") and selected_chat.get("answer").strip():
                    with st.chat_message("assistant"):
                        st.markdown(selected_chat["answer"])
                        
                        # Quellen anzeigen falls vorhanden
                        sources = selected_chat.get("sources", [])
                        if sources and isinstance(sources, list) and len(sources) > 0:
                            st.markdown("**üìö Quellen:**")
                            for j, source in enumerate(sources, 1):
                                if isinstance(source, dict):
                                    source_text = source.get("content", "")[:200]
                                    source_file = source.get("metadata", {}).get("source", "Unbekannt")
                                    st.markdown(f"*{j}. {source_file}*: {source_text}...")
                                else:
                                    st.text(f"{j}. {source}")
            else:
                st.info("Chat nicht gefunden oder leer.")
        else:
            st.info("W√§hle links einen Eintrag aus, um Frage & Antwort zu sehen.")



async def update_available_sources():
    try:
        # response = (supabase_client.client.table("rag_pages").select("url, metadata").execute()

        # neu (Service-Client f√ºr data_user und admin, RLS f√ºr andere):
        sb = get_db_client_for_upload_operations()
        response = sb.table("rag_pages").select("url, metadata").execute()


        file_set = set()
        knowledge_set = set()

        for row in response.data:
            metadata = row.get("metadata", {})
            url = row.get("url", "")
            if not url:
                continue

            if metadata.get("source") == "ui_upload":
                file_set.add(url)
            elif metadata.get("source") == "manuell":
                knowledge_set.add(url)

        # üëá Kombinieren und sortieren
        all_sources = sorted(file_set.union(knowledge_set))

        st.session_state.sources = all_sources
        st.session_state.document_count = len(file_set)
        st.session_state.knowledge_count = len(knowledge_set)

    except Exception as e:
        print(f"Fehler beim Aktualisieren der Dokumentenliste: {e}")
        for key in [
            "sources",
            "document_count",
            "knowledge_count",
            "processed_files",
            "messages",
        ]:
            if key in st.session_state:
                del st.session_state[key]

async def main():
    # 0) Login erzwingen
    ensure_login()

    # Erst Daten laden, dann Header rendern
    await update_available_sources()
    render_header()
    
    # Always-on agentic retrieval configuration (no sidebar needed)
    # agentic_config = render_agentic_config_sidebar()  # REMOVED - always on now

    doc_count = st.session_state.get("document_count", 0)
    note_count = st.session_state.get("knowledge_count", 0)

    # Initialisierung des Flags
    if "just_uploaded" not in st.session_state:
        st.session_state.just_uploaded = False

    # Robuste Initialisierung aller ben√∂tigten session_state Variablen
    if "messages" not in st.session_state:
        st.session_state.messages = []

    if "sources" not in st.session_state:
        st.session_state.sources = []

    if "document_count" not in st.session_state:
        try:
            st.session_state.document_count = supabase_client.count_documents()
        except Exception as e:
            print(f"Fehler beim Abrufen der Dokumentenzahl: {e}")
            st.session_state.document_count = 0

    if "processed_files" not in st.session_state:
        st.session_state.processed_files = set()

    # ---- Rollenbasierte Tabs ----
    tab_labels = []
    
    # Chat-Bereich (chatbot_user, data_user, admin)
    if has_permission("chat"):
        tab_labels.append("üí¨ Wunsch-√ñle KI Assistent")
    
    # Wissen hinzuf√ºgen / Doku hochladen (data_user, admin)  
    if has_permission("upload"):
        tab_labels.append("‚ûï Wissen hinzuf√ºgen")
    
    # Dokumente anzeigen / l√∂schen (data_user, admin)
    if has_permission("delete"):
        tab_labels.append("üóëÔ∏è Dokument anzeigen / l√∂schen")
    
    # Benutzerverwaltung (nur admin)
    if get_user_role() == "admin":
        tab_labels.append("üë§ Benutzerverwaltung")
    
    if not tab_labels:
        st.warning("Keine berechtigten Bereiche mit deinen Rollen.")
        return
        
    tabs = st.tabs(tab_labels)
    current_tab = 0

    def render_user_management():
        """Renders the user management UI for admins."""
        st.markdown("### üë§ Benutzerverwaltung")
        st.markdown("---")
        
        # Neuen Benutzer anlegen
        st.markdown("#### ‚ûï Neuen Benutzer anlegen")
        with st.container():
            col1, col2 = st.columns([2, 1])
            
            with col1:
                new_email = st.text_input("E-Mail-Adresse", key="new_user_email")
                new_password = st.text_input("Passwort (erforderlich, mind. 8 Zeichen)", 
                                           type="password", key="new_user_password")
            
            with col2:
                st.markdown("**Rolle ausw√§hlen:**")
                selected_role = st.radio(
                    "",
                    options=["admin", "data_user", "chatbot_user"],
                    format_func=lambda x: {
                        "admin": "üîß Administrator (alle Rechte)",
                        "data_user": "üìä Data User (Dokumente verwalten + Chat)", 
                        "chatbot_user": "üí¨ Chatbot User (nur Chat + Historie)"
                    }[x],
                    key="new_user_role",
                    label_visibility="collapsed"
                )
            
            if st.button("Benutzer anlegen", type="primary"):
                if not new_email.strip():
                    st.error("Bitte E-Mail eingeben.")
                    st.stop()
                if not new_password.strip():
                    st.error("Bitte ein Passwort eingeben.")
                    st.stop()
                if len(new_password.strip()) < 8:
                    st.error("Passwort zu kurz (mind. 8 Zeichen).")
                    st.stop()
                    
                if create_user(new_email.strip(), [selected_role], new_password.strip()):
                    st.rerun()
        
        st.markdown("---")
        
        # Bestehende Benutzer verwalten
        st.markdown("#### üë• Bestehende Benutzer verwalten")
        
        users = list_users()
        if users:
            for user in users:
                with st.container():
                    col1, col2, col3 = st.columns([2, 3, 2])
                    
                    with col1:
                        st.markdown(f"**{user['email']}**")
                        st.caption(f"ID: {user['id'][:8]}...")
                    
                    with col2:
                        st.markdown("**Rolle:**")
                        user_roles = user.get('roles', [])
                        current_role = user_roles[0] if user_roles else "chatbot_user"
                        
                        new_role = st.radio(
                            "",
                            options=["admin", "data_user", "chatbot_user"],
                            format_func=lambda x: {
                                "admin": "üîß Administrator",
                                "data_user": "üìä Data User",
                                "chatbot_user": "üí¨ Chatbot User"
                            }[x],
                            index=["admin", "data_user", "chatbot_user"].index(current_role),
                            key=f"role_{user['id']}",
                            label_visibility="collapsed"
                        )
                    
                    with col3:
                        # Action Buttons
                        if st.button("üíæ Rolle speichern", key=f"save_{user['id']}"):
                            if set_roles(user['id'], [new_role]):
                                st.success("Rolle aktualisiert!")
                                st.rerun()
                        
                        # Sicherheitsabfrage f√ºr L√∂schen
                        delete_confirm = st.checkbox("Best√§tigen", key=f"confirm_{user['id']}")
                        if st.button("üóëÔ∏è L√∂schen", 
                                   disabled=not delete_confirm, 
                                   key=f"delete_{user['id']}"):
                            if delete_user(user['id']):
                                st.success("Benutzer gel√∂scht!")
                                st.rerun()
                    
                    st.markdown("---")
        else:
            st.info("Keine Benutzer gefunden oder Fehler beim Laden.")
        
        # Hinweise
        with st.expander("Hinweise", expanded=True):
            st.markdown("- Passw√∂rter k√∂nnen Benutzer im User-Men√º oben rechts selbst √§ndern.")
            st.markdown("- Nach Rollen-Updates m√ºssen betroffene Benutzer sich neu einloggen.")
            
    async def render_delete_preview_ui():
        """Renders the complete document/note preview and delete UI."""
        # Custom CSS for better text readability in preview areas
        st.markdown(
        """
        <style>
        /* Improve readability of disabled text areas - use very light background and black text */
        .stTextArea textarea[disabled] {
            color: #000000 !important;
            background-color: #f8f9fa !important;
            opacity: 1 !important;
            font-family: 'Source Code Pro', monospace !important;
            line-height: 1.5 !important;
            border: 1px solid #dee2e6 !important;
            -webkit-text-fill-color: #000000 !important;
        }
        
        /* Force black text color with higher specificity */
        div[data-testid="stTextArea"] textarea[disabled] {
            color: #000000 !important;
            -webkit-text-fill-color: #000000 !important;
        }
        
        /* Also apply to regular text areas for consistency */
        .stTextArea textarea {
            line-height: 1.5 !important;
        }
        </style>
        """,
            unsafe_allow_html=True,
        )

        # Zeige Vorschau nur wenn Benutzer die del-Berechtigung hat
        if st.session_state.sources and has_permission("delete"):
            delete_filename = st.selectbox(
                "Dokument/Notiz selektieren", st.session_state.sources
            )

            # Vorschau anzeigen mit Button auf gleicher H√∂he
            col1, col2 = st.columns([3, 1])
            with col1:
                st.markdown(
                    "<h5 style='margin-top: 0rem; margin-bottom: 0.5rem;'>üìÑ Vorschau</h5>",
                    unsafe_allow_html=True,
                )
            with col2:
                delete_button_pressed = st.button(
                    "üóëÔ∏è Ausgew√§hltes Dokument/Notiz l√∂schen", key="delete_doc_button"
                )

            # Metadaten und Inhalt aus Supabase holen
            try:
                sb = get_db_client_for_admin_operations()
                res = (
                    sb.table("rag_pages")
                    .select("content", "metadata", "chunk_number")
                    .eq("url", delete_filename)
                    .order("chunk_number")  # Chunks in richtiger Reihenfolge
                    .execute()
                )

                if res.data:
                    # F√ºr manuelle Notizen alle Chunks zusammensetzen
                    first_entry = res.data[0]
                    metadata = first_entry.get("metadata", {})
                    source = metadata.get("source", "")
                    
                    if source == "manuell" and len(res.data) > 1:
                        # Mehrere Chunks -> zusammensetzen (agentisch gechunkte Notiz)
                        content_parts = []
                        for entry in res.data:
                            chunk_content = entry.get("content", "")
                            if chunk_content.strip():
                                content_parts.append(chunk_content.strip())
                        
                        # Chunks mit Zeilentrennung zusammenf√ºgen
                        content = "\n\n".join(content_parts)
                        st.info(f"üìÑ Lange Notiz rekonstruiert aus {len(res.data)} agentisch erzeugten Chunks")
                    else:
                        # Einzelner Chunk oder andere Dokumente
                        content = first_entry.get("content", "")

                    if source == "manuell":
                        # Put title and source side by side
                        col1, col2 = st.columns([2, 1])
                        with col1:
                            st.markdown(
                                f"**Titel:** {metadata.get('title', 'Unbekannt')}"
                            )
                        with col2:
                            st.markdown(f"**Quelle:** {metadata.get('quelle', '‚Äì')}")

                        # Use text_area with proper line breaks and scrolling like text files
                        st.text_area(
                            "Notizinhalt",
                            content,
                            height=400,
                            disabled=True,
                            key=f"note_preview_{hash(delete_filename)}",
                        )
                    else:
                        # Unterscheidung zwischen PDF und TXT Dateien
                        original_filename = metadata.get("original_filename", "")
                        file_extension = metadata.get("file_extension", "").lower()

                        # Fallback: Determine file extension from filename if not in metadata
                        if not file_extension and original_filename:
                            if "." in original_filename:
                                file_extension = (
                                    "." + original_filename.lower().split(".")[-1]
                                )
                            else:
                                file_extension = ""

                        if file_extension == ".pdf":
                            # Original PDF anzeigen
                            try:
                                st.markdown("**üìÑ Original-PDF Vorschau:**")

                                # Create signed URL dynamically for PDF preview
                                client = get_supabase_client()
                                try:
                                    res = client.storage.from_(
                                        "privatedocs"
                                    ).create_signed_url(original_filename, 3600)
                                    signed_url = res.get("signedURL")

                                    if signed_url and signed_url != "#":
                                        st.markdown("**PDF-Inhalt:**")

                                        # Try multiple PDF viewer approaches for maximum compatibility

                                        # Approach 1: Try Mozilla PDF.js viewer first (most reliable)
                                        pdfjs_url = f"https://mozilla.github.io/pdf.js/web/viewer.html?file={signed_url}"

                                        st_components.html(
                                            f"""
                                            <div style="width: 100%; height: 800px; border: 1px solid #ccc; border-radius: 6px; margin-top: 10px; position: relative;">
                                                <iframe 
                                                    src="{pdfjs_url}" 
                                                    width="100%" 
                                                    height="100%" 
                                                    style="border: none; border-radius: 6px;"
                                                    frameborder="0"
                                                    onload="console.log('PDF.js loaded successfully')"
                                                    onerror="console.error('PDF.js failed to load'); this.style.display='none'; document.getElementById('fallback-{hash(signed_url)}').style.display='block';">
                                                </iframe>
                                                
                                                <!-- Fallback for when PDF.js doesn't work -->
                                                <div id="fallback-{hash(signed_url)}" style="display: none; padding: 20px; text-align: center; height: 100%;">
                                                    <div style="margin-top: 200px;">
                                                        <h3>PDF-Vorschau nicht verf√ºgbar</h3>
                                                        <p>Der PDF-Viewer konnte nicht geladen werden.</p>
                                                        <a href="{signed_url}" target="_blank" 
                                                           style="display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-size: 16px;">
                                                            üìÑ PDF in neuem Tab √∂ffnen
                                                        </a>
                                                    </div>
                                                </div>
                                                
                                                <div style="position: absolute; bottom: 0; left: 0; right: 0; text-align: center; padding: 5px; background: rgba(248,249,250,0.9); border-top: 1px solid #dee2e6;">
                                                    <small>
                                                        <a href="{signed_url}" target="_blank" style="color: #007bff; text-decoration: none;">
                                                            üìÑ PDF in neuem Tab √∂ffnen
                                                        </a>
                                                    </small>
                                                </div>
                                            </div>
                                            """,
                                            height=820,
                                        )
                                    else:
                                        st.warning(
                                            "‚ö†Ô∏è PDF-Vorschau konnte nicht geladen werden. Signed URL nicht verf√ºgbar."
                                        )
                                        st.info(f"Debug: Response: {res}")

                                except Exception as url_error:
                                    st.error(
                                        f"‚ùå Fehler beim Erstellen der PDF-Vorschau URL: {url_error}"
                                    )
                                    st.info("Versuche alternative Anzeige...")

                                    # Fallback: Show text content if available
                                    if content and content.strip():
                                        st.markdown("**Extrahierter Text-Inhalt:**")
                                        st.text_area(
                                            "PDF Textinhalt",
                                            content,
                                            height=400,
                                            disabled=True,
                                            key=f"pdf_text_preview_{hash(delete_filename)}",
                                        )
                                    else:
                                        st.warning(
                                            "Keine PDF-Vorschau oder Textinhalt verf√ºgbar."
                                        )

                            except Exception as e:
                                st.error(f"‚ùå Fehler beim Laden der PDF-Vorschau: {e}")
                                # Show text content as fallback
                                if content and content.strip():
                                    st.markdown(
                                        "**Extrahierter Text-Inhalt (Fallback):**"
                                    )
                                    st.text_area(
                                        "PDF Textinhalt",
                                        content,
                                        height=400,
                                        disabled=True,
                                        key=f"pdf_fallback_preview_{hash(delete_filename)}",
                                    )
                        elif file_extension == ".txt":
                            # TXT-Datei Vorschau
                            try:
                                st.markdown("**üìÑ Text-Datei Vorschau:**")
                                # Put filename, file size and chunks on same line
                                col1, col2, col3 = st.columns([2, 1, 1])
                                with col1:
                                    st.markdown(f"**Dateiname:** {original_filename}")
                                with col2:
                                    st.markdown(
                                        f"**Dateigr√∂√üe:** {metadata.get('file_size_bytes', 0)} Bytes"
                                    )
                                with col3:
                                    st.markdown(
                                        f"**Chunks:** {metadata.get('chunk_count', 1)}"
                                    )

                                st.text_area(
                                    "Dateiinhalt",
                                    content,
                                    height=400,
                                    disabled=True,
                                    key=f"txt_preview_{hash(delete_filename)}",
                                )
                            except Exception as e:
                                st.error(f"Fehler beim Laden der TXT-Vorschau: {e}")
                        else:
                            # Fallback f√ºr andere Dateitypen
                            st.markdown(
                                f"**üìÑ Dokument Vorschau ({original_filename}):**"
                            )
                            st.markdown(
                                f"**Dateityp:** {file_extension if file_extension else 'Unbekannt'}"
                            )
                            st.markdown("**Inhalt:**")
                            st.text_area(
                                "Dokumentinhalt",
                                content,
                                height=400,
                                disabled=True,
                                key=f"doc_preview_{hash(delete_filename)}",
                            )
                else:
                    st.info("Keine Vorschau verf√ºgbar.")

            except Exception as e:
                st.error(f"Fehler beim Laden der Vorschau: {e}")

            if delete_button_pressed:
                st.write("Dateiname zur L√∂schung:", delete_filename)

                storage_deleted = db_deleted = False

                # Erst Datenbank, dann Storage l√∂schen (umgekehrte Reihenfolge)
                try:
                    print(f"üóëÔ∏è L√∂sche Datenbankeintr√§ge f√ºr: {delete_filename}")
                    
                    # Use appropriate client (Service for admin, User for others)
                    sb = get_db_client_for_admin_operations()
                    delete_result = sb.table("rag_pages").delete().eq("url", delete_filename).execute()
                    deleted_count = len(delete_result.data or [])
                    
                    st.code(
                        f"ü©® SQL-Delete f√ºr '{delete_filename}' ‚Äì {deleted_count} Eintr√§ge entfernt."
                    )
                    if deleted_count > 0:
                        db_deleted = True
                        print(
                            f"‚úÖ {deleted_count} Datenbankeintr√§ge erfolgreich gel√∂scht"
                        )
                    else:
                        print(
                            f"‚ö†Ô∏è Keine Datenbankeintr√§ge f√ºr {delete_filename} gefunden"
                        )
                except Exception as e:
                    error_msg = str(e).lower()
                    if "403" in error_msg or "forbidden" in error_msg or "not allowed" in error_msg:
                        st.error("‚ùå L√∂schung nicht erlaubt. Nur Administratoren k√∂nnen Dokumente l√∂schen.")
                        print(f"üö´ RLS-Blockierung: Benutzer hat keine L√∂schberechtigung f√ºr {delete_filename}")
                    else:
                        st.error(f"Datenbank-L√∂schung fehlgeschlagen: {e}")
                        print(f"‚ùå Datenbank-L√∂schung fehlgeschlagen: {e}")
                    db_deleted = False

                try:
                    print(f"üóëÔ∏è L√∂sche Storage-Datei: {delete_filename}")
                    # Use appropriate client (Service for admin, User for others)
                    sb = get_db_client_for_admin_operations()
                    sb.storage.from_("privatedocs").remove(
                        [delete_filename]
                    )
                    storage_deleted = True
                    print(f"‚úÖ Storage-Datei erfolgreich gel√∂scht")
                except Exception as e:
                    error_msg = str(e).lower()
                    if "403" in error_msg or "forbidden" in error_msg or "not allowed" in error_msg:
                        st.error("‚ùå Storage-L√∂schung nicht erlaubt. Nur Administratoren k√∂nnen Dateien aus dem Speicher l√∂schen.")
                        print(f"üö´ RLS-Blockierung: Benutzer hat keine Storage-L√∂schberechtigung f√ºr {delete_filename}")
                    else:
                        st.error(f"L√∂schen aus dem Speicher fehlgeschlagen: {e}")
                        print(f"‚ùå Storage-L√∂schung fehlgeschlagen: {e}")

                # Zus√§tzliche Verifikation: Pr√ºfe ob wirklich gel√∂scht
                try:
                    print(
                        f"üîç Verifikation: Pr√ºfe ob {delete_filename} wirklich gel√∂scht wurde..."
                    )
                    sb = get_db_client_for_admin_operations()
                    verify_result = (
                        sb.table("rag_pages")
                        .select("id,url")
                        .eq("url", delete_filename)
                        .execute()
                    )
                    remaining_entries = len(verify_result.data or [])
                    if remaining_entries > 0:
                        print(
                            f"‚ö†Ô∏è WARNUNG: {remaining_entries} Eintr√§ge f√ºr {delete_filename} sind noch in der Datenbank!"
                        )
                        st.warning(
                            f"‚ö†Ô∏è {remaining_entries} Eintr√§ge sind noch in der Datenbank vorhanden!"
                        )
                        # Versuche nochmal zu l√∂schen
                        print("üîÑ Versuche erneute L√∂schung...")
                        retry_deleted = supabase_client.delete_documents_by_filename(
                            delete_filename
                        )
                        print(
                            f"üîÑ Zweiter L√∂schversuch: {retry_deleted} Eintr√§ge entfernt"
                        )
                    else:
                        print(
                            f"‚úÖ Verifikation erfolgreich: Keine Eintr√§ge f√ºr {delete_filename} gefunden"
                        )
                except Exception as e:
                    print(f"‚ùå Verifikation fehlgeschlagen: {e}")
                    st.error(f"Verifikation fehlgeschlagen: {e}")

                if storage_deleted and db_deleted:
                    st.success("‚úÖ Vollst√§ndig gel√∂scht.")
                    # Remove from processed files list so it can be re-uploaded
                    if "processed_files" in st.session_state:
                        # Remove all entries that match this filename
                        files_to_remove = [
                            f
                            for f in st.session_state.processed_files
                            if delete_filename in f
                        ]
                        for file_to_remove in files_to_remove:
                            st.session_state.processed_files.discard(file_to_remove)
                            print(f"üßπ Entfernt aus processed_files: {file_to_remove}")
                elif storage_deleted and not db_deleted:
                    st.warning(
                        "‚ö†Ô∏è Dokument/Notiz im Storage gel√∂scht, aber kein Eintrag in der Datenbank gefunden."
                    )
                elif not storage_deleted and db_deleted:
                    st.warning(
                        "‚ö†Ô∏è Datenbankeintr√§ge gel√∂scht, aber Dokument/Notiz im Storage konnte nicht entfernt werden."
                    )
                else:
                    st.error(
                        "‚ùå Weder Dokument/Notiz noch Datenbankeintr√§ge konnten gel√∂scht werden."
                    )

                # Cache leeren und Quellen aktualisieren
                print("üîÑ Aktualisiere verf√ºgbare Quellen nach L√∂schung...")
                await update_available_sources()

                # Zus√§tzlich: Session State Cache leeren
                cache_keys_to_clear = ["sources", "document_count", "knowledge_count"]
                for key in cache_keys_to_clear:
                    if key in st.session_state:
                        old_value = st.session_state[key]
                        del st.session_state[key]
                        print(f"üßπ Cache geleert: {key} (war: {old_value})")

                print("üîÑ Seite wird neu geladen...")
                st.rerun()

        else:
            st.info("Keine Dokumente/Notizen zur L√∂schung verf√ºgbar.")

    # Chat-Tab (immer der erste verf√ºgbare Tab f√ºr berechtigte Benutzer)
    if has_permission("chat"):
        # Sicherstellen, dass ein Thread aktiv ist
        if st.session_state.current_thread_id is None:
            new_thread()
        
        # Synchronisiere current_user_name mit tats√§chlichem User
        if st.session_state.get("user"):
            st.session_state.current_user_name = st.session_state["user"].email
        
        with tabs[current_tab]:
            # Erstelle Untermen√º mit zwei Optionen (ohne doppelten Titel)
            chat_tab1, chat_tab2 = st.tabs(["Chat", "Chat Historie"])

        with chat_tab1:
            # Thread-Liste (Sidebar)
            with st.sidebar:
                st.subheader("Chat Historie")
                if st.session_state.get("user"):
                    threads = list_threads_for_user(st.session_state.current_user_name)
                    if threads:
                        options = {f'{t["thread_title"]} ¬∑ {t["thread_id"][:8]}': t["thread_id"] for t in threads}
                        if options:
                            current_selection = None
                            # Find current selection by thread_id
                            for display_name, thread_id in options.items():
                                if thread_id == st.session_state.current_thread_id:
                                    current_selection = display_name
                                    break
                            
                            sel = st.selectbox(
                                "Threads", 
                                list(options.keys()),
                                index=list(options.keys()).index(current_selection) if current_selection else 0
                            )
                            if st.button("Thread √∂ffnen"):
                                st.session_state.current_thread_id = options[sel]
                                st.rerun()
                    else:
                        st.info("Keine Threads vorhanden")

            # Thread-ID anzeigen - entfernt wie gew√ºnscht

            # EINGABEBEREICH OBEN - persistent unter den Tabs
            st.markdown('<div style="margin: 0.5rem 0; border-top: 1px solid #e0e0e0; padding-top: 1rem;"></div>', unsafe_allow_html=True)
            col_input, col_button = st.columns([4, 1])
            
            with col_input:
                user_input = st.chat_input("Stelle eine Frage zu den Dokumenten...")
            
            with col_button:
                # Button h√∂her platzieren - weniger Padding
                st.markdown("<div style='padding-top: 0.2rem;'></div>", unsafe_allow_html=True)
                if st.button("üÜï Neuer Thread", use_container_width=True, help="Neuen Thread starten"):
                    new_thread()
                    st.rerun()

            # CSS f√ºr Chat-Layout (vereinfacht)
            st.markdown("""
            <style>
            .stChatMessage {
                margin-bottom: 1rem !important;
            }
            </style>
            """, unsafe_allow_html=True)

            # CHAT-VERLAUF DARUNTER (umgekehrte Reihenfolge - neueste oben) 
            with st.container(height=600, border=True):
                # Thread laden & rendern in UMGEKEHRTER Reihenfolge
                _rows = load_thread(st.session_state.current_thread_id)
                
                if _rows:
                    # Umgekehrte Reihenfolge: neueste Q/A-Paare zuerst
                    reversed_rows = list(reversed(_rows))
                    for i, r in enumerate(reversed_rows):
                        # Innerhalb eines Q/A-Paares: Frage zuerst, dann Antwort
                        if r.get("question"):
                            with st.chat_message("user"):
                                st.markdown(r["question"])
                        
                        if r.get("answer"):
                            with st.chat_message("assistant"):
                                st.markdown(r["answer"])
                                
                                # Quellen korrekt anzeigen mit format_source_reference
                                if st.session_state.get('last_agentic_matches'):
                                    sources = st.session_state.get('last_agentic_matches', [])
                                    if sources and isinstance(sources, list) and len(sources) > 0:
                                        st.markdown("---")
                                        for source in sources:
                                            if isinstance(source, dict):
                                                # Verwende die originale format_source_reference Funktion
                                                formatted_ref = format_source_reference(source)
                                                st.markdown(formatted_ref, unsafe_allow_html=True)
                        
                        if i < len(reversed_rows) - 1:  # Trennlinie zwischen Q/A-Paaren
                            st.markdown("---")

            # Chat-Input Verarbeitung (√ºber chat_input mit ENTER)
            if user_input:
                q = user_input.strip()
                
                if q:
                    print(f"üîµ [USER INPUT] Frage erhalten: {q[:50]}...")

                    # 1) Kontext f√ºr Agenten aus aktuellem Thread
                    rows_for_ctx = load_thread(st.session_state.current_thread_id)
                    thread_messages = build_agent_context(rows_for_ctx)

                    # 2) RAG/Agent mit Thread-Kontext aufrufen (ohne Status-Updates)
                    try:
                        # Verwende die RAG-Agent Instanz mit Thread-Kontext
                        rag_agent_instance = get_rag_agent()
                        
                        # Tempor√§r: Setze den Thread-Kontext in session_state.messages
                        # f√ºr die Kompatibilit√§t mit run_agent_with_streaming
                        original_messages = st.session_state.get("messages", [])
                        st.session_state.messages = thread_messages
                        
                        # Streaming-Response sammeln
                        full_response = ""
                        async for chunk in run_agent_with_streaming(q, rag_agent_instance):
                            full_response += chunk if chunk else ""
                        
                        # Urspr√ºngliche Messages wiederherstellen
                        st.session_state.messages = original_messages
                        
                        answer = full_response.strip()
                        
                    except Exception as e:
                        print(f"‚ùå Fehler bei RAG Agent: {e}")
                        # Fallback auf agentic retrieval
                        agentic_config = get_always_on_agentic_config(q)
                        agentic_result = await run_agentic_retrieval(q, agentic_config)
                        answer = agentic_result.get("answer", "")

                    # 3) Persistieren als Q/A-Paar im Thread
                    source_chunks = st.session_state.get('last_agentic_matches', [])
                    
                    save_chat_row(
                        user_name=st.session_state.current_user_name,
                        question=q,
                        answer=answer,
                        sources=source_chunks
                    )

                    # Seite neu laden um neue Nachricht anzuzeigen
                    st.rerun()

        with chat_tab2:
            # Chat Historie implementiert
            render_chat_history()

    # Add-Tab (zweiter Tab wenn verf√ºgbar)
    if has_permission("upload"):
        tab_index = 0
        if has_permission("chat"):
            tab_index = 1
        with tabs[tab_index]:
            # Erstelle Untermen√º mit zwei Optionen (ohne doppelten Titel)
            knowledge_tab1, knowledge_tab2 = st.tabs(
                ["Notiz hinzuf√ºgen", "Dokumente hochladen"]
            )

        with knowledge_tab1:
            st.markdown(
                "Du kannst hier eigene Notizen, Feedback oder Empfehlungen eintragen, die sofort durchsuchbar sind."
            )

            # Initialisierung f√ºr Erfolgs-/Fehlermeldungen und Reset-Counter
            if "note_save_message" not in st.session_state:
                st.session_state.note_save_message = ""
            if "input_reset_counter" not in st.session_state:
                st.session_state.input_reset_counter = 0

            # Eingabefelder mit dynamischen Keys f√ºr Reset-Funktionalit√§t
            reset_suffix = st.session_state.input_reset_counter
            manual_title = st.text_input(
                "üè∑Ô∏è √úberschrift",
                key=f"manual_title_input_{reset_suffix}",
            )
            manual_text = st.text_area(
                "‚úçÔ∏è Dein Wissen", 
                key=f"manual_text_input_{reset_suffix}"
            )

            # Handle manuelle Quelle sicher
            source_options = ["Wissen", "Beratung", "Meeting", "Feedback", "Sonstiges"]
            source_type = st.selectbox(
                "Kategorie",
                source_options,
                index=1,  # Default zu "Beratung"
                key=f"manual_source_input_{reset_suffix}",
            )

            # Speichern-Button
            if st.button("‚úÖ Wissen / Notiz speichern", key="save_button"):
                    # Clear any previous messages and table
                    st.session_state.note_save_message = ""
                    if "note_processing_table" in st.session_state:
                        del st.session_state.note_processing_table

                    if not manual_title.strip() or not manual_text.strip():
                        st.warning(
                            "‚ö†Ô∏è Bitte gib sowohl eine √úberschrift als auch einen Text ein."
                        )
                    else:
                        # Initialize processing table
                        table_data = [{
                            "Titel": manual_title.strip(),
                            "Text": manual_text.strip()[:50] + "..." if len(manual_text.strip()) > 50 else manual_text.strip(),
                            "Kategorie": source_type,
                            "Status": "‚è≥ Wird verarbeitet..."
                        }]
                        
                        # Create a progress table
                        table_placeholder = st.empty()
                        table_placeholder.table(table_data)
                        
                        def update_note_table(progress, status):
                            table_data[0]["Fortschritt"] = progress
                            table_data[0]["Status"] = status
                            table_placeholder.table(table_data)
                            st.session_state.note_processing_table = table_data.copy()

                        try:
                            # Step 1: Initial validation
                            update_note_table("5%", "üîÑ Pr√ºfung...")
                            
                            sb = get_db_client_for_upload_operations()
                            existing = (
                                sb.table("rag_pages")
                                .select("url")
                                .ilike("url", f"{manual_title.strip()}%")
                                .execute()
                            )
                            if existing.data:
                                update_note_table("Bereits vorhanden", "‚ö†Ô∏è √úbersprungen")
                                st.warning(
                                    f"‚ö†Ô∏è Ein Eintrag mit der √úberschrift '{manual_title.strip()}' existiert bereits."
                                )
                            else:
                                # Step 2: Prepare filename
                                update_note_table("10%", "üîÑ Vorbereitung...")
                                
                                # Use appropriate client (Service for data_user and admin, User for others)
                                sb_user = get_db_client_for_upload_operations()
                                pipeline = DocumentIngestionPipeline(db_client=sb_user)
                                tz_berlin = pytz.timezone("Europe/Berlin")
                                now_berlin = datetime.now(tz_berlin)
                                timestamp = now_berlin.strftime("%Y-%m-%d %H:%M")

                                # Complete note processing logic would continue here
                                update_note_table("100%", "‚úÖ Gespeichert")
                                st.session_state.note_save_message = "‚úÖ Notiz erfolgreich gespeichert!"
                                
                                # Clear table and reset inputs after success
                                if "note_processing_table" in st.session_state:
                                    del st.session_state.note_processing_table
                                st.session_state.input_reset_counter += 1
                                st.rerun()
                                
                        except Exception as e:
                            # Set error message and update table
                            error_msg = str(e).replace("\\n", " ")[:100]
                            update_note_table(f"Fehler: {error_msg[:30]}...", "‚ùå Fehlgeschlagen") 
                            st.session_state.note_save_message = f"‚ùå Fehler beim Speichern: {error_msg}"


            # Always display persistent note processing table if it exists
            if "note_processing_table" in st.session_state and st.session_state.note_processing_table:
                st.subheader("üìä Notiz-Verarbeitung")
                st.table(st.session_state.note_processing_table)

            # Display success/error message below buttons
            if st.session_state.note_save_message:
                if st.session_state.note_save_message.startswith("‚úÖ"):
                    st.success(st.session_state.note_save_message)
                elif st.session_state.note_save_message.startswith("‚ùå"):
                    st.error(st.session_state.note_save_message)
                else:
                    st.info(st.session_state.note_save_message)

        with knowledge_tab2:
            st.markdown(
                """
                <small>(max. 200 MB pro Datei ‚Ä¢ PDF oder TXT)</small>
            """,
                unsafe_allow_html=True,
            )

            # File upload interface
            uploaded_files = st.file_uploader(
                "Dateien hochladen",
                accept_multiple_files=True,
                type=["pdf", "txt"],
                help="PDF- oder TXT-Dateien hochladen. Mehrere Dateien k√∂nnen gleichzeitig ausgew√§hlt werden."
            )

            # Basic upload processing (simplified for now)
            if uploaded_files:
                st.info(f"üìÅ {len(uploaded_files)} Datei(en) ausgew√§hlt. Upload-Funktionalit√§t wird verarbeitet...")

    # Delete-Tab (dritter Tab wenn verf√ºgbar)  
    if has_permission("delete"):
        tab_index = 0
        if has_permission("chat"):
            tab_index += 1
        if has_permission("upload"): 
            tab_index += 1
        
        with tabs[tab_index]:
            st.info("üóëÔ∏è L√∂sch-Funktionalit√§t - wird hier implementiert")

    # Benutzerverwaltung-Tab (vierter Tab wenn verf√ºgbar)
    if has_permission("user_management"):
        tab_index = 0
        if has_permission("chat"):
            tab_index += 1
        if has_permission("upload"):
            tab_index += 1
        if has_permission("delete"):
            tab_index += 1
            
        with tabs[tab_index]:
            st.info("üë• Benutzerverwaltung - wird hier implementiert")

if __name__ == "__main__":
    asyncio.run(main())
